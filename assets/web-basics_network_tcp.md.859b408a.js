import{_ as e,c,o,N as a}from"./chunks/framework.78c68b71.js";const B=JSON.parse('{"title":"TCP","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/network/tcp.md","lastUpdated":1670155339000}'),d={name:"web-basics/network/tcp.md"},t=a('<h1 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h1><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><p>这里假设 A(client) 以及 B(server)</p><p>A和B握手过程:</p><ol><li>A 发送 <code>syn</code> 报文给B ( 此时A状态为 <code>syn_sent</code> )</li><li>B 收到 <code>syn</code> 报文,并发送 <code>ack + syn</code> 报文给 A ( 此时B状态为 <code>syn_rcvd</code> )</li><li>A 发送 <code>ack</code> 报文给B ( <code>ack</code>可以理解为确定收到了的意思 )</li></ol><p>syn_sent和syn_rcvd,这两个状态叫着「半打开」状态,就是向对方招手了,但是还没得到对方回应(rcvd = received)</p><ul><li>syn_sent是主动打开方的「半打开」状态</li><li>syn_rcvd是被动打开方的「半打开」状态</li><li>这里A是主动打开方,B是被动打开方</li></ul><h2 id="数据传输" tabindex="-1">数据传输 <a class="header-anchor" href="#数据传输" aria-label="Permalink to &quot;数据传输&quot;">​</a></h2><p>接着A和B开始互相传递数据,会一直重复着这样的场景:<br> A发送data给B,B接收到后需要回复A <code>ack</code> 报文,表示已收到数据</p><ul><li><p>tcp重传 在上面的场景中,如果A发送给B的数据丢失了或者A没有接收到B的回复,那么A不管是发生了什么都会重新传一遍给B</p></li><li><p>tcp去重 接着上面的重传场景,那么A有可能会发送两次数据给B,这样就会有数据重复了,不过 <code>重传 &amp; 去重</code> 的工作操作系统网络模块已经帮我们处理好了</p></li><li><p>批量ack A如果连续发很多次数据给B,B也不会每个都回一句 <code>ack</code>,它会统一回复一次 <code>ack</code> 表示收到数据</p></li><li><p>tcp窗口大小 但是A不能一次发太多数据,A和B要保持一定的发送和接收频率,这个叫做 <code>tcp</code> 窗口大小</p></li></ul><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><p>挥手过程:</p><ol><li>A 发送 <code>fin</code> 报文给B (此时A状态为 <code>fin_wait_1</code>)</li><li>B 发送 <code>ack</code> 报文给A (此时A状态为 <code>fin_wait_2</code>, B状态为 <code>close_wait</code>)</li><li>B 发送 <code>fin</code> 报文给A (此时A状态为 <code>time_wait</code>, B状态为 <code>last_ack</code> )</li><li>A 发送 <code>ack</code> 报文给B (此时B状态为 <code>close</code>)</li></ol><p>这里tcp存在半关闭状态,也就是单向关闭,比如A已经取消发送了,但是不会取消接收,B可以接着发没有发送完的数据,等B也不发送数据且回复A <code>ack</code> 报文,那么才代表彻底结束</p><ul><li><p><code>time_wait</code>状态解释:<br> 是主动关闭的一方在接收到对方挥手后才进入的长期状态,时长为4分钟,4分钟过后主动关闭的一方才进入 <code>close</code> 状态,它的作用是重传最后一个 <code>ack</code> 报文,确保对方收到,对方没有收到则会重传 <code>fin</code> 报文</p></li><li><p>4分钟解释:<br> 4分钟是2个MSL,MSL是最长报文寿命,数据的来回一下就是两个了</p></li></ul><p>本篇参考此博文 <a href="https://juejin.cn/post/6844903625513238541#comment" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903625513238541#comment</a></p>',16),i=[t];function l(n,r,s,p,_,A){return o(),c("div",null,i)}const k=e(d,[["render",l]]);export{B as __pageData,k as default};
