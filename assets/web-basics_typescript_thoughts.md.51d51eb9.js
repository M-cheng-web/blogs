import{_ as s,c as a,o as n,N as t}from"./chunks/framework.78c68b71.js";const A=JSON.parse('{"title":"一些感想","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/typescript/thoughts.md","lastUpdated":1678763937000}'),e={name:"web-basics/typescript/thoughts.md"},l=t(`<h1 id="一些感想" tabindex="-1">一些感想 <a class="header-anchor" href="#一些感想" aria-label="Permalink to &quot;一些感想&quot;">​</a></h1><h2 id="为什么存在-ts" tabindex="-1">为什么存在 ts <a class="header-anchor" href="#为什么存在-ts" aria-label="Permalink to &quot;为什么存在 ts&quot;">​</a></h2><h3 id="一开始有些抗拒" tabindex="-1">一开始有些抗拒 <a class="header-anchor" href="#一开始有些抗拒" aria-label="Permalink to &quot;一开始有些抗拒&quot;">​</a></h3><p>老实说虽然早就接触了ts,而且在上家公司也用上了,但还是感觉挺抗拒的,原因是过多的不必要的代码,比如一个页面所有的功能代码(加上axios请求以及公共utils)是300行,那么加上ts后会有400行的代码甚至更多,特别体现在接口方面的定义上,如果后端接口返回数据本身就很怪异而且因为一些 &quot;人为原因&quot; 导致数据总是不符合期望,那么我做这些严格校验就像是在浮萍上盖楼</p><h3 id="过后思考" tabindex="-1">过后思考 <a class="header-anchor" href="#过后思考" aria-label="Permalink to &quot;过后思考&quot;">​</a></h3><p>私下自己想了想,或许是因为我负责的项目比较单一,就两三个前端甚至一个前端一个项目这种就行,如果一直这样的话谁愿意用ts啊,都是自己写的代码都非常熟了,谁愿意多写一些限制自己的东西是不?</p><p>但很明显,我们这一行并不是一滩死水,你负责的永远不可能只是某个,某块项目,我试想如果我是技术管理者也不希望有这样的情况,一方面是离职成本会很大:只有他熟悉那一块代码,无论是离职还是换个业务线都不大好;二方面是每个人更像是一枚螺丝钉了,只负责自己熟悉的代码不利于团队技术进步</p><h3 id="拥抱ts" tabindex="-1">拥抱ts <a class="header-anchor" href="#拥抱ts" aria-label="Permalink to &quot;拥抱ts&quot;">​</a></h3><p>如果用上了ts,让我们来看看有哪些改变</p><ol><li>如果你被突然切换到某个业务线并且要你在当天就有产出,再夸张点就是你必须一个小时内修复一个其他项目的线上bug,按照我以前用js的习惯一般会把一整条逻辑走完我才开始写代码(充分理解每个参数是什么意思,函数内部做了什么返回了什么),如果此项目加上了严格的ts,基本上会杜绝你写出低级bug,而且也能辅助你认识关键代码的入参出参快速修复bug</li><li>你不可能一直遇上经常出现 &quot;人为原因&quot; 的后端把,如果遇上了请让其更加严格的要求自己</li></ol><h3 id="从技术角度解读ts优点" tabindex="-1">从技术角度解读ts优点 <a class="header-anchor" href="#从技术角度解读ts优点" aria-label="Permalink to &quot;从技术角度解读ts优点&quot;">​</a></h3><ul><li>js在运行代码前并不知道函数调用的结果,甚至不知道函数是否能被调用</li><li>代码补全,快速修复更加得心应手</li><li>ts类型系统可以正确推断出一些标识符相对应的类型</li></ul><h2 id="安装-配置" tabindex="-1">安装 &amp; 配置 <a class="header-anchor" href="#安装-配置" aria-label="Permalink to &quot;安装 &amp; 配置&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 安装</span></span>
<span class="line"><span style="color:#A6ACCD;">npm install -g typescript</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 编译</span></span>
<span class="line"><span style="color:#A6ACCD;">tsc index.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">(没有tsc命令也可以用 npx tsc index.ts)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="vscode-配置自动编译" tabindex="-1">vscode 配置自动编译 <a class="header-anchor" href="#vscode-配置自动编译" aria-label="Permalink to &quot;vscode 配置自动编译&quot;">​</a></h3><ol><li>进行一些配置</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 生成 tsconfig.json 文件</span></span>
<span class="line"><span style="color:#A6ACCD;">ts -init</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 在 tsconfig.json 文件内配置</span></span>
<span class="line"><span style="color:#A6ACCD;">&quot;outDir&quot;: &quot;./js&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol start="2"><li>在目标单文件中, <code>command + shift + b</code>,然后选择你的 tsconfig 文件</li><li>随后在你的目标 <code>index.ts</code> 文件中执行 <code>tsc index.ts</code></li><li>就此你的每次操作都会自动打包</li></ol><h3 id="tsconfig-json-其他配置" tabindex="-1">tsconfig.json 其他配置 <a class="header-anchor" href="#tsconfig-json-其他配置" aria-label="Permalink to &quot;tsconfig.json 其他配置&quot;">​</a></h3><p>TypeScript 提供的形式更像是一个刻度盘,你越是转动它,TypeScript 就会检查越多的内容</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&quot;strict&quot;: true 严格模式</span></span>
<span class="line"><span style="color:#A6ACCD;">noImplicitAny: true 当隐式类型被推断为any时会抛出一个错误</span></span>
<span class="line"><span style="color:#A6ACCD;">strictNullChecks: true 选项会让我们更明确的处理 null 和 undefined,也会让我们免于忧虑是否忘记处理 null 和 undefined</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div>`,21),o=[l];function i(p,c,r,d,h,u){return n(),a("div",null,o)}const b=s(e,[["render",i]]);export{A as __pageData,b as default};
