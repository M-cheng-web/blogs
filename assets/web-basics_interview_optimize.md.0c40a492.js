import{_ as s,c as a,o as l,N as o}from"./chunks/framework.78c68b71.js";const d=JSON.parse('{"title":"优化","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/interview/optimize.md","lastUpdated":1670155339000}'),e={name:"web-basics/interview/optimize.md"},n=o(`<h1 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h1><p><img src="https://gitee.com/M-cheng-web/map-storage/raw/master/vue-img/58082bb8d51e463291a98012efd26c55_tplv-k3u1fbpfcp-watermark.webp" alt="性能优化简图"></p><h2 id="优化webpack" tabindex="-1">优化webpack <a class="header-anchor" href="#优化webpack" aria-label="Permalink to &quot;优化webpack&quot;">​</a></h2><p>参考 <a href="/blog/tools/webpack/index" rel="noreferrer">webpack</a></p><h2 id="优化dom" tabindex="-1">优化DOM <a class="header-anchor" href="#优化dom" aria-label="Permalink to &quot;优化DOM&quot;">​</a></h2><ul><li>删除不必要的代码和注释包括空格,尽量做到最小化文件</li><li>可以利用 GZIP 压缩文件 (这个主要是服务器端压缩,浏览器自动解压)</li><li>结合 HTTP 缓存文件 (一般情况资源用协商缓存,依赖用强缓存)</li></ul><h2 id="优化cssom" tabindex="-1">优化CSSOM <a class="header-anchor" href="#优化cssom" aria-label="Permalink to &quot;优化CSSOM&quot;">​</a></h2><p>DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析,但是渲染树是依赖于 DOM Tree 和 CSSOM Tree 的,所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染</p><p><strong>因此,CSS 加载会阻塞 Dom 的渲染,由此可见对于 CSSOM 缩小、压缩以及缓存同样重要</strong></p><ul><li>减少关键 CSS 元素</li><li>骨架屏</li></ul><h2 id="优化js" tabindex="-1">优化JS <a class="header-anchor" href="#优化js" aria-label="Permalink to &quot;优化JS&quot;">​</a></h2><ul><li>路由懒加载(预加载)</li><li>不重要资源设置浏览器空闲加载</li><li>script标签设置 <ul><li>async: 浏览器遇到这个 script 标记时会继续解析 DOM,同时脚本也不会被 CSSOM 阻止 (可以理解为标记此标签内无DOM操作)</li><li>defer: 标记此脚本内容在文档解析后再执行</li></ul></li><li>link标签预加载 -- preload &amp; prefetch (预加载和其他页面的预加载,prefetch还可以缓存至少5分钟)</li><li>dns预加载 -- dns-prefetch (意思是在本页面提前设定几个dns预加载,让用户进行页面跳转时再请求的资源能被dns先预加载)</li><li>节流防抖</li></ul><h3 id="preload-prefetch" tabindex="-1">preload &amp; prefetch <a class="header-anchor" href="#preload-prefetch" aria-label="Permalink to &quot;preload &amp; prefetch&quot;">​</a></h3><ul><li>preload 场景: 如果网站使用一种特殊字体,我们在css里面定义了字体的url,那么直到浏览器开始解析CSS了才会识别出来需要加载这个资源,会影响首屏出来的速度,可以让浏览器提前下载好此资源</li></ul><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">preload</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fonts/cicle_fina-webfont.woff</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">as</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">font</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">font/woff</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">crossorigin</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">anonymous</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">1. rel =&quot;preolad&quot; 声明这是一个preload</span></span>
<span class="line"><span style="color:#A6ACCD;">2. href指明资源的位置</span></span>
<span class="line"><span style="color:#A6ACCD;">3. as指明资源类型 (这是为了让浏览器精确设置优先级,设置正确的CSP,Accept头部)</span></span>
<span class="line"><span style="color:#A6ACCD;">4. crossorigin 指明使用的跨域设置</span></span>
<span class="line"></span></code></pre></div><p>注意: preload 并不会阻塞正常的渲染流程,它只是在浏览器初次请求时把这个资源的请求加进去了,然后等待这个资源被调用</p><p>还可以响应式预加载</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">preload</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bg-image-narrow.png</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">as</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">image</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">media</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">(max-width: 600px)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">preload</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bg-image-wide.png</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">as</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">image</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">media</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">(min-width: 800px)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ul><li>prefetch 预先加载下个页面的资源<br> 比如这里就是预先加载 <code>main.js</code> 的页面资源( 用户此时并不在main页面 )</li></ul><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">prefetch</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">main.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>注意: 这个预加载是在浏览器空闲的时候加载的,并不占用初始请求资源</p><h2 id="vue优化" tabindex="-1">vue优化 <a class="header-anchor" href="#vue优化" aria-label="Permalink to &quot;vue优化&quot;">​</a></h2><h3 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-label="Permalink to &quot;服务端渲染&quot;">​</a></h3><p>vue是单页面应用,首屏会出来的较慢,可以考虑用服务端渲染和预渲染(Nuxt)</p><ul><li>服务端渲染: 发送请求 -&gt; 服务端请求数据渲染html -&gt; 返回包含首屏的html</li><li>预渲染: 发送请求 -&gt; 返回包含首屏的html</li><li>客户端渲染: 发送请求 -&gt; 拿到html -&gt; js加载并动态渲染</li></ul><h3 id="按需加载组件" tabindex="-1">按需加载组件 <a class="header-anchor" href="#按需加载组件" aria-label="Permalink to &quot;按需加载组件&quot;">​</a></h3><p><a href="https://juejin.cn/post/6844903496102199304#comment" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903496102199304#comment</a></p><h3 id="提取各个组件css到单独文件" tabindex="-1">提取各个组件css到单独文件 <a class="header-anchor" href="#提取各个组件css到单独文件" aria-label="Permalink to &quot;提取各个组件css到单独文件&quot;">​</a></h3><p>当使用单文件组件时,组件内的 CSS 会以 <code>&lt;style&gt;</code> 标签的方式通过 JavaScript 动态注入 这有一些小小的运行时开销,将所有组件的 CSS 提取到同一个文件可以避免这个问题,也会让 CSS 更好地进行压缩和缓存</p><p>这一点通过webpack实现,提取到一个文件还可以去重</p><h3 id="object-freeze" tabindex="-1">Object.freeze() <a class="header-anchor" href="#object-freeze" aria-label="Permalink to &quot;Object.freeze()&quot;">​</a></h3><p>Object.freeze() 可以冻结一个对象,冻结之后不能向这个对象添加新的属性,不能修改其已有属性的值,不能删除已有属性,以及不能修改该对象已有属性的可枚举性、可配置性、可写性,该方法返回被冻结的对象</p><p><strong>在vue中, <code>Object.defineProperty</code> 不会为冻结的对象添加数据劫持,个人感觉可以在项目中高效使用了</strong></p>`,33),p=[n];function t(r,c,i,D,F,y){return l(),a("div",null,p)}const u=s(e,[["render",t]]);export{d as __pageData,u as default};
