import{_ as s,c as a,o as l,N as e}from"./chunks/framework.78c68b71.js";const D=JSON.parse('{"title":"预构建","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/vite/prebuild.md","lastUpdated":1670155339000}'),n={name:"web-basics/vite/prebuild.md"},o=e(`<h1 id="预构建" tabindex="-1">预构建 <a class="header-anchor" href="#预构建" aria-label="Permalink to &quot;预构建&quot;">​</a></h1><p>vite是提倡 <code>no-bundle</code> 的构建工具,相比于webpack能做到开发时的模块代码按需编译,这里的模块代码分为源代码(业务代码)和第三方代码(node_modules中的代码),对于源代码vite才会采取 <code>no-bundle</code> ,对于第三方代码vite还是会打包,并且利用的是速度极快的esbuild来完成,打包第三方代码的过程可以理解为预构建</p><h2 id="为什么需要预构建" tabindex="-1">为什么需要预构建 <a class="header-anchor" href="#为什么需要预构建" aria-label="Permalink to &quot;为什么需要预构建&quot;">​</a></h2><ol><li>第三方插件不支持esm: 因为vite利用的是浏览器原生支持的esm规范实现的 <code>dev server</code>,所以内容应该都遵循esm规范,但是很多第三方的打包规范并没有支持esm版本,这个过程需要预构建来把包处理为esm版本</li><li>插件内过多的引用: 因为资源的加载都是利用浏览器直接加载的,但是有些库会有非常多的基础引用,这有的时候会带来卡顿</li></ol><p>依赖预构建主要做了两件事情:</p><ol><li>将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式,使其在浏览器通过 <code>&lt;script type=&quot;module&quot;&gt;&lt;script&gt;</code> 的方式正常加载</li><li>是打包第三方库的代码,将各个第三方库分散的文件合并到一起,减少 HTTP 请求数量,避免页面加载性能劣化</li></ol><p>而这两件事情全部由性能优异的 Esbuild 完成的</p><h2 id="如何开启预构建" tabindex="-1">如何开启预构建 <a class="header-anchor" href="#如何开启预构建" aria-label="Permalink to &quot;如何开启预构建&quot;">​</a></h2><p>Vite 设置了本地文件系统的缓存,所有的预构建产物默认缓存在node_modules/.vite目录中,如果以下 3 个地方都没有改动,Vite 将一直使用缓存文件:</p><ul><li>package.json 的 dependencies 字段</li><li>各种包管理器的 lock 文件</li><li>optimizeDeps 配置内容</li></ul><p>少数场景下我们不希望用本地的缓存文件,比如需要调试某个包的预构建结果,推荐使用下面任意一种方法清除缓存,还有手动开启预构建:</p><ul><li>删除node_modules/.vite目录</li><li>在 Vite 配置文件中,将server.force设为true</li><li>命令行执行npx vite --force或者npx vite optimize</li></ul><blockquote><p>对于依赖的请求结果,Vite 的 Dev Server 会设置强缓存(设置一年,表示缓存过期前浏览器对某个预构建产物的请求不会再经过 Vite Dev Server,直接用缓存结果)</p></blockquote><h2 id="include" tabindex="-1">include <a class="header-anchor" href="#include" aria-label="Permalink to &quot;include&quot;">​</a></h2><p>强制预构建的依赖项</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vite.config.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">optimizeDeps</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 配置为一个字符串数组,将 \`lodash-es\` 和 \`vue\`两个包强制进行预构建</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">include</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lodash-es</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>使用场景:</p><ol><li>动态 import</li><li>某些包被手动 exclude</li></ol><p>场景1: 在动态引入时,vite会重新走一遍预构建(也叫做二次预构建),还会刷新页面,还会重新请求所有模块,这在大型项目中是很浪费性能的,所以我们可以先对其进行预构建,在真正使用到的时候可以避免二次预加载</p><p>场景2: exclude是排除一些包,不让其进入预构建,比如通过cdn引入的插件就不需要加入构建过程,但是如果引入的这个插件又用到了其他插件,而这个插件又不支持esm格式,那么vite就会打包报错,这时候需要主动 include 引入此插件先</p><h2 id="自定义-esbuild" tabindex="-1">自定义 Esbuild <a class="header-anchor" href="#自定义-esbuild" aria-label="Permalink to &quot;自定义 Esbuild&quot;">​</a></h2><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vite.config.ts</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">optimizeDeps</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">esbuildOptions</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">       </span><span style="color:#FFCB6B;">plugins</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 加入 Esbuild 插件</span></span>
<span class="line"><span style="color:#F07178;">      ]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>使用场景例如: 第三方包出现问题</p><ol><li>解决1: Esbuild插件替换</li><li>解决2: 修改插件源代码后,通过 <code>patch-package</code> 插件同步第三方源代码更改</li></ol>`,24),p=[o];function t(i,c,r,d,F,u){return l(),a("div",null,p)}const h=s(n,[["render",t]]);export{D as __pageData,h as default};
