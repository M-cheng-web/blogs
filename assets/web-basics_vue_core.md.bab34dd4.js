import{_ as s,c as a,o as l,N as n}from"./chunks/framework.78c68b71.js";const u=JSON.parse('{"title":"vue","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/vue/core.md","lastUpdated":1676300903000}'),o={name:"web-basics/vue/core.md"},e=n(`<h1 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h1><p><a href="https://vue3js.cn/interview/vue/show_if.html#%E4%B8%80%E3%80%81v-show%E4%B8%8Ev-if%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9" target="_blank" rel="noreferrer">https://vue3js.cn/interview/vue/show_if.html#一、v-show与v-if的共同点</a></p><h2 id="组件通信方式" tabindex="-1">组件通信方式 <a class="header-anchor" href="#组件通信方式" aria-label="Permalink to &quot;组件通信方式&quot;">​</a></h2><h2 id="vue-observable" tabindex="-1">Vue.observable <a class="header-anchor" href="#vue-observable" aria-label="Permalink to &quot;Vue.observable&quot;">​</a></h2><p>在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 引入vue</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> Vue </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建state对象，使用observable让state对象可响应</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observable</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">38</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建对应的方法</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> mutations </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">changeName</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">setAge</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">age</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">age</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">age</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="修饰符" tabindex="-1">修饰符 <a class="header-anchor" href="#修饰符" aria-label="Permalink to &quot;修饰符&quot;">​</a></h2><h3 id="表单修饰符" tabindex="-1">表单修饰符 <a class="header-anchor" href="#表单修饰符" aria-label="Permalink to &quot;表单修饰符&quot;">​</a></h3><ul><li>lazy</li><li>trim</li><li>number</li></ul><h3 id="事件修饰符" tabindex="-1">事件修饰符 <a class="header-anchor" href="#事件修饰符" aria-label="Permalink to &quot;事件修饰符&quot;">​</a></h3><ul><li>stop</li><li>prevent</li><li>self</li><li>once</li><li>capture (使事件触发从包含这个元素的顶层开始往下触发)</li><li>passive (在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符)</li><li>native (让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件)</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">my-component</span><span style="color:#89DDFF;"> v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="鼠标按钮修饰符" tabindex="-1">鼠标按钮修饰符 <a class="header-anchor" href="#鼠标按钮修饰符" aria-label="Permalink to &quot;鼠标按钮修饰符&quot;">​</a></h3><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p><p>left 左键点击 right 右键点击 middle 中键点击</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;</span></span>
<span class="line"></span></code></pre></div><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h2><p>nextTick 主要使用了宏任务和微任务,根据执行环境分别尝试采用</p><ul><li>Promise</li><li>MutationObserver</li><li>setImmediate</li><li>如果以上都不行则采用 setTimeout</li></ul><p>由于Vue的异步更新策略导致我们对数据的修改不会立马体现到都没变化上,此时如果想要立即获取更新后的dom的状态,就需要使用这个方法,比如以下代码</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">mounted</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">123</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 具体意思不用管,知道这个打印输出的元素是负责展示 this.name 的就行</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeOut</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 123</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>Vue在更新dom时是异步执行的,只要监听到数据变化,Vue将开启一个队列,并缓冲在同一事件循环中发生的所有数据变更 如果同一个watcher被多次触发,只会被推入到队列中一次,这种在缓存时去重对于避免不必要的计算和dom操作是非常重要的nextTick方法会在队列中加入一个回调函数,确保该函数在前面的dom操作完成后才调用</p><p>nextTick 就是利用任务队列的原理,为什么要用异步,因为数据更新后的DOM操作都是异步,我们要做的是在同一事件循环的末尾接上一个队列就行,有四个选项供我们选择</p><h2 id="组件中的data为什么是一个函数" tabindex="-1">组件中的data为什么是一个函数 <a class="header-anchor" href="#组件中的data为什么是一个函数" aria-label="Permalink to &quot;组件中的data为什么是一个函数&quot;">​</a></h2><p>一个组件被复用多次的话,也就会创建多个实例 本质上,这些实例用的都是同一个构造函数,如果data是对象的话,对象属于引用类型,会影响到所有的实例 所以为了保证组件不同的实例之间data不冲突,data必须是一个函数</p><p>关于这一点可以参考原型链那一块知识点,自己试一下就知道改变 <code>Object.prototype.A属性</code> 会触发所有实例的 <code>A属性</code> 改变</p><ul><li>根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li><li>组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象</li></ul><h2 id="给对象添加新属性" tabindex="-1">给对象添加新属性 <a class="header-anchor" href="#给对象添加新属性" aria-label="Permalink to &quot;给对象添加新属性&quot;">​</a></h2><ul><li>$Set</li><li>Object.assign (this.obj = Object.assign({}, this.obj, {age: 1}))</li><li>$forceUpdate (强制更新视图)</li></ul><h2 id="router" tabindex="-1">router <a class="header-anchor" href="#router" aria-label="Permalink to &quot;router&quot;">​</a></h2><ul><li>beforeEach afterEach (全局)</li><li>beforeEnter (单个路由独享)</li><li>beforeRouteEnter beofreRouteUpdate beforeRouteLeave (组件级别)</li></ul><h2 id="key" tabindex="-1">key <a class="header-anchor" href="#key" aria-label="Permalink to &quot;key&quot;">​</a></h2><p>能帮助vue高效 diff,比如在一个 <code>for</code> 循环渲染出的列表中,当这个列表某几条数据发生更改时,会经历以下步骤 (可以从第6步开始看),在知道渲染过程后,可以假设这样的场景: 有一个列表渲染,都是拿index作为key,当插入一条数据的时候,后面的key都会发生变化,都会重新渲染,这样是不符合key的初衷的</p><ol><li>触发watcher,随之触发watcher对象的 update(), 然后再触发渲染函数</li><li>渲染函数利用 h 函数生成这一块最新的虚拟DOM树</li><li>随后会触发 patch 函数对比新旧虚拟DOM树</li><li>patch 函数内部会判断出父级没有变化,变化是子级</li><li>随后会进行深层的 diff 算法比较(参考diff算法篇)</li><li>diff 算法内部会依赖于 <code>sel</code> 以及 <code>key</code> 来判断是不是同一个元素</li><li>如果是同一个元素就会只改变其内容或者移一下位置就行</li><li>这样就不用重复创建真实DOM元素了,能复用的都复用</li></ol><h2 id="data值变化触发的动作" tabindex="-1">data值变化触发的动作 <a class="header-anchor" href="#data值变化触发的动作" aria-label="Permalink to &quot;data值变化触发的动作&quot;">​</a></h2><h3 id="值的动作" tabindex="-1">值的动作 <a class="header-anchor" href="#值的动作" aria-label="Permalink to &quot;值的动作&quot;">​</a></h3><ul><li>场景一 data的值没有在页面渲染</li><li>场景二 data的值在页面上有使用</li><li>场景三 data的值在页面上有使用,且被computed属性调用</li><li>场景四 data的值在页面上有使用,且被computed属性调用,且computed属性被页面使用</li></ul><h3 id="渲染的动作" tabindex="-1">渲染的动作 <a class="header-anchor" href="#渲染的动作" aria-label="Permalink to &quot;渲染的动作&quot;">​</a></h3><p>模板语法 =&gt; 抽象语法树ast =&gt; 渲染函数(h函数) =&gt; 虚拟节点 =&gt; 界面</p><p>在data值改变之前,页面就已经经过了上面的步骤( 在生成虚拟DOM时会把data的真实时放在虚拟DOM对象中 ),此时更改会触发以下步骤( 这里的前提是data属性被页面调用 ):</p><ol><li>data值的变化会触发拦截,随后会触发渲染 <code>watcher</code>对象的update</li><li>update方法又会触发其渲染函数</li><li>渲染函数内部又会由 h 函数转化为虚拟DOM</li><li>随后比较新旧虚拟DOM</li><li>由于这里只是更改了内容,并不涉及子级的比较,所以不用 diff算法</li><li>在对比过程中发现新旧虚拟DOM只是内容发生了变化</li><li>将新虚拟DOM的内容赋值给旧虚拟DOM,并不会重新创建个新元素</li><li>也就是这样的操作: <code>oldVnode.elm.innerText = newVnode.text</code></li></ol><h2 id="vue2与vue3差异" tabindex="-1">vue2与vue3差异 <a class="header-anchor" href="#vue2与vue3差异" aria-label="Permalink to &quot;vue2与vue3差异&quot;">​</a></h2><ul><li>支持有多个根节点</li><li>响应监听proxy</li><li>Teleport (模板移动到任意DOM)</li><li>composition Api</li><li>v-model 用法已更改 可以有多个v-model</li><li>v-if 和 v-for 优先级更改为 v-if优先，但同时还是不建议一起用，会有警告</li><li>diff算法优化</li><li>静态提升</li></ul><h3 id="diff算法优化" tabindex="-1">diff算法优化 <a class="header-anchor" href="#diff算法优化" aria-label="Permalink to &quot;diff算法优化&quot;">​</a></h3><p>vue3在diff算法中相比vue2增加了静态标记</p><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较</p><h3 id="静态提升" tabindex="-1">静态提升 <a class="header-anchor" href="#静态提升" aria-label="Permalink to &quot;静态提升&quot;">​</a></h3><p>Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">你好</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 这个就会做静态提升</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">{{ message }}</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="mvvm区别" tabindex="-1">MVVM区别 <a class="header-anchor" href="#mvvm区别" aria-label="Permalink to &quot;MVVM区别&quot;">​</a></h3><ul><li>Object.defineProperty只能遍历对象属性进行劫持</li><li>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</li></ul><h3 id="slot" tabindex="-1">slot <a class="header-anchor" href="#slot" aria-label="Permalink to &quot;slot&quot;">​</a></h3><ul><li>在vue2.0中,被解析到 this.$slots.default[0].data.attrs 这个对象中</li><li>在vue3.0中,被解析到 this.$slots.default()[0].props 这个对象中</li></ul><p>像这个组件的默认插槽里面还有默认插槽</p><ul><li>在vue2.0中,会被解析到 this.$slots.default[0].data.scopedSlots 这个对象中</li><li>在vue3.0中,会被解析到 this.$slots.default()[0].children 这个数组中</li></ul><p>错误场景:</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 父级</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:selfTextArr</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">selfTextArr</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:fontStyle</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fontStyle</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:isCenterLine</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">isCenterLine</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">// 子级</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-slot:default</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">slotProps</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">drag-area</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-show</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">slotProps.selfTextArr.length === 0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">{&#39;drag-area-text&#39;: slotProps.isCenterLine}</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:style</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">slotProps.fontStyle</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      点击输入文字</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>父级通过 <code>this.$slots.default()[0]</code> 语句发现会报错, <code>isCenterLine is undefined</code> 这样的,无奈只能给父级 slot 外层加个 div,然后通过那个div去获取到插槽作用域</p><p>后续: 可以通过 <code>useSlots</code> hook函数获取到(没试过,应该可以)</p><h3 id="v3的命名问题" tabindex="-1">v3的命名问题 <a class="header-anchor" href="#v3的命名问题" aria-label="Permalink to &quot;v3的命名问题&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">originCanvas</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 下面这种命名会导致赋值失效</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$originCanvas</span></span>
<span class="line"></span></code></pre></div><h3 id="teleport" tabindex="-1">Teleport <a class="header-anchor" href="#teleport" aria-label="Permalink to &quot;Teleport&quot;">​</a></h3><p><code>&lt;Teleport&gt;</code> 接收一个 to prop 来指定传送的目标。to 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段传送到 body 标签下”</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">Teleport</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">body</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">open</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">modal</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello from the modal!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">open = false</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Close</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">Teleport</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div>`,65),p=[e];function t(c,r,i,D,F,y){return l(),a("div",null,p)}const h=s(o,[["render",t]]);export{u as __pageData,h as default};
