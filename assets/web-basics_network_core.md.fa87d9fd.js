import{_ as l,c as a,o as i,N as e}from"./chunks/framework.78c68b71.js";const q=JSON.parse('{"title":"网络","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/network/core.md","lastUpdated":1675691846000}'),t={name:"web-basics/network/core.md"},o=e('<h1 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h1><h2 id="页面加载和渲染过程" tabindex="-1">页面加载和渲染过程 <a class="header-anchor" href="#页面加载和渲染过程" aria-label="Permalink to &quot;页面加载和渲染过程&quot;">​</a></h2><ul><li><p>加载过程</p><ol><li>DNS解析: 域名 -&gt; IP地址</li><li>发起 TCP 连接</li><li>浏览器根据 IP地址向服务器发起 http请求</li><li>服务器处理 http请求 并返回给浏览器</li></ol></li><li><p>渲染过程</p><ol><li>解析HTML生成DOM树</li><li>解析CSS生成CSSOM规则树</li><li>解析JS 操作 DOM 树和 CSSOM 规则树</li><li>将DOM树与CSSOM规则树合并在一起生成渲染树</li><li>遍历渲染树开始布局,计算每个节点的位置大小信息</li><li>浏览器将所有图层的数据发送给GPU,GPU将图层合成并显示在屏幕上</li></ol></li></ul><h2 id="http状态码" tabindex="-1">http状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;http状态码&quot;">​</a></h2><ul><li>1xx: 指示信息 – 表示请求已接收</li><li>2xx: 成功 – 表示请求已被成功接收</li><li>3xx: 重定向 – 要完成请求必须进行更进一步的操作</li><li>4xx: 客户端错误 – 请求有语法错误或请求无法实现</li><li>5xx: 服务器端错误 – 服务器未能实现合法的请求</li></ul><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><h3 id="dns解析" tabindex="-1">DNS解析 <a class="header-anchor" href="#dns解析" aria-label="Permalink to &quot;DNS解析&quot;">​</a></h3><p>输入 <code>www.baidu.com</code> 网址后,会依照此顺序获得 <code>IP</code></p><ol><li>本地域名服务器 (会去DNS缓存找一下,没有的话会接着往下找)</li><li>根域名服务器</li><li>com 顶级域名服务器</li><li>baidu.com 域名服务区</li></ol><h3 id="dns缓存" tabindex="-1">DNS缓存 <a class="header-anchor" href="#dns缓存" aria-label="Permalink to &quot;DNS缓存&quot;">​</a></h3><p>DNS存在多级缓存,从离浏览器距离排序分别为:</p><ol><li>浏览器缓存</li><li>系统缓存</li><li>路由器缓存</li><li>IPS服务器缓存</li><li>根域名服务器缓存</li><li>顶级域名服务器缓存</li><li>主域名服务器缓存</li></ol><h3 id="dns负载均衡" tabindex="-1">DNS负载均衡 <a class="header-anchor" href="#dns负载均衡" aria-label="Permalink to &quot;DNS负载均衡&quot;">​</a></h3><p>在访问 <code>baidu.com</code> 时,每次响应的并非是同一个服务器(IP地址),一般大公司有几百台服务器来支撑访问,DNS在这里做了相对应的优化:<br> 返回一个适合机器的IP给用户,比如根据每台机器的负载量,机器距离用户距离等等,这种过程叫做负载均衡</p><h2 id="http缓存" tabindex="-1">http缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;http缓存&quot;">​</a></h2><p>浏览器有一个缓存数据库,用来保存一些静态文件</p><h3 id="缓存规则" tabindex="-1">缓存规则 <a class="header-anchor" href="#缓存规则" aria-label="Permalink to &quot;缓存规则&quot;">​</a></h3><ul><li><p>强制缓存<br> 当缓存数据库中有客户端需要的数据,客户端直接将数据从其中拿出来使用 (如果数据未失效),当缓存服务器没有需要的数据时,客户端才会向服务端请求</p></li><li><p>协商缓存<br> 客户端会先从缓存数据库拿到一个缓存的标识,然后向服务端验证标识是否失效,如果没有失效服务端会返回304,这样客户端可以直接去缓存数据库拿出数据,如果失效,服务端会返回新的数据</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>强制缓存的优先级高于协商缓存,若两种缓存皆存在,且强制缓存命中目标,则协商缓存不再验证标识</p></div><h3 id="缓存方案" tabindex="-1">缓存方案 <a class="header-anchor" href="#缓存方案" aria-label="Permalink to &quot;缓存方案&quot;">​</a></h3><h4 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;强制缓存&quot;">​</a></h4><p>服务器的响应头会有 <code>Cache-Control</code> 来表明是否强制缓存,它的参数为:</p><ul><li>private: 客户端可以缓存</li><li>public: 客户端和代理服务器都可以缓存</li><li>max-age=t: 缓存内容将在t秒后失效</li><li>no-cache: 需要使用协商缓存来验证缓存数据</li><li>no-store: 所有内容都不会缓存</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><ul><li><p><code>Last-Modified</code> 服务器在响应请求时,会告诉浏览器资源的<strong>最后修改时间</strong>,附带在此参数上<br> 当浏览器再次请求时会带上此时间,服务器会对比此时间,当一致时会返回304,然后浏览器取缓存,当不一致时证明此文件发生了变化,服务器开始响应执行相关操作,然后返回200</p></li><li><p><code>Etag</code> 此字段告诉浏览器当前资源在服务器生成的唯一标识<br> 当浏览器再次请求时会带上此标识,服务器通过对比此标识是否一致来决定是否返回304</p></li></ul><blockquote><p>由于这个标识是服务器通过算法得出的,会占用服务器资源,所以这种方法比较少用</p></blockquote><h3 id="缓存优点" tabindex="-1">缓存优点 <a class="header-anchor" href="#缓存优点" aria-label="Permalink to &quot;缓存优点&quot;">​</a></h3><ul><li>减少多余的数据传递,节省宽带流量</li><li>减少服务器的负担</li><li>加快客户端加载网页速度</li></ul><h3 id="不同刷新的缓存现象" tabindex="-1">不同刷新的缓存现象 <a class="header-anchor" href="#不同刷新的缓存现象" aria-label="Permalink to &quot;不同刷新的缓存现象&quot;">​</a></h3><ul><li>浏览器写入URL - 发现有缓存,不用请求直接拿</li><li>F5刷新 - 协商缓存,会去服务器看资源是否过期</li><li>Ctrl + F5(也就是清空缓存并硬刷新) - 删除缓存后去服务器请求完整文件</li></ul><h2 id="get-post-区别" tabindex="-1">Get/Post 区别 <a class="header-anchor" href="#get-post-区别" aria-label="Permalink to &quot;Get/Post 区别&quot;">​</a></h2><ul><li>GET在浏览器回退时是无害的,而POST会再次提交请求</li><li>GET请求会被浏览器主动cache,而POST不会</li><li>GET请求只能进行url编码,而POST支持多种编码方式</li><li>GET参数通过URL传递,POST放在Request body中</li><li>GET请求参数会被完整保留在浏览器历史记录里,而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的,而POST没有</li><li>GET比POST更不安全,因为参数直接暴露在URL上,所以不能用来传递敏感信息。</li></ul><h2 id="回流重绘" tabindex="-1">回流重绘 <a class="header-anchor" href="#回流重绘" aria-label="Permalink to &quot;回流重绘&quot;">​</a></h2><p>会引起元素位置变化的就会回流,窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置</p><p>不会引起位置变化的,只是在以前的位置进行改变背景颜色等,只会重绘</p><p><strong>回流必将引起重绘,重绘不一定会引起回流</strong></p><h3 id="两者对性能影响" tabindex="-1">两者对性能影响 <a class="header-anchor" href="#两者对性能影响" aria-label="Permalink to &quot;两者对性能影响&quot;">​</a></h3><p><strong>回流比重绘的代价要更高</strong><br> 有时即使仅仅回流一个单一的元素,它的父元素以及任何跟随它的元素也会产生回流<br></p><p>现代浏览器会对频繁的回流或重绘操作进行优化:<br> 浏览器会维护一个队列,把所有引起回流和重绘的操作放入队列中,如果队列中的任务数量或者时间间隔达到一个阈值的,浏览器就会将队列清空,进行一次批处理,这样可以把多次回流和重绘变成一次</p><h3 id="如何避免重绘和回流" tabindex="-1">如何避免重绘和回流 <a class="header-anchor" href="#如何避免重绘和回流" aria-label="Permalink to &quot;如何避免重绘和回流&quot;">​</a></h3><p>css:</p><ul><li>避免使用table布局</li><li>避免设置多层内联样式</li><li>将动画效果应用到position属性为absolute或fixed的元素上</li></ul><p>js:</p><ul><li>避免频繁操作样式,或者最好一次性重写style</li><li>避免频繁操作DOM,创建一个documentFragment,在上面做一些操作,最后才把它添加到文档中</li></ul><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><p>同源策略: 协议,端口号,域名相同</p><ul><li>动态创建script 因为script标签不受同源策略影响</li><li>link 标签</li><li>img 标签</li><li>JSONP 在axios请求参数内加个 jsonp</li><li>CORS 配置 axios.defaults.withCredentials = true 允许跨域携带cookie信息</li><li>websocket</li><li>nginx反向代理</li></ul><h2 id="http-和-https" tabindex="-1">HTTP 和 HTTPS <a class="header-anchor" href="#http-和-https" aria-label="Permalink to &quot;HTTP 和 HTTPS&quot;">​</a></h2><p>https = http + ssl协议</p><h3 id="https-优点" tabindex="-1">https 优点 <a class="header-anchor" href="#https-优点" aria-label="Permalink to &quot;https 优点&quot;">​</a></h3><ul><li>seo: 谷歌调整过搜索引擎算法,比起同等http网站,https加密的网站的排名更高</li><li>安全性</li></ul><h3 id="https-缺点" tabindex="-1">https 缺点 <a class="header-anchor" href="#https-缺点" aria-label="Permalink to &quot;https 缺点&quot;">​</a></h3><ul><li>https协议会使页面的加载时间延长 <code>50%</code>,增加 <code>10% - 20%</code> 耗电</li><li>加密范围有限,黑客攻击,服务器劫持几乎没有作用</li><li>ssl证书需要钱</li><li>https链接服务器端资源占用高很多</li><li>https在握手阶段比较费时,对网站响应速度有影响</li></ul><h2 id="页面存储" tabindex="-1">页面存储 <a class="header-anchor" href="#页面存储" aria-label="Permalink to &quot;页面存储&quot;">​</a></h2><h3 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h3><ul><li>大小限制为4kb</li><li>可设置失效时间,默认关闭浏览器后清除</li><li>数据自动携带于请求头中</li></ul><h3 id="sessionstorage" tabindex="-1">sessionStorage <a class="header-anchor" href="#sessionstorage" aria-label="Permalink to &quot;sessionStorage&quot;">​</a></h3><ul><li>大小5MB左右</li><li>关闭页面或者浏览器后清除</li></ul><h3 id="localstorage" tabindex="-1">localStorage <a class="header-anchor" href="#localstorage" aria-label="Permalink to &quot;localStorage&quot;">​</a></h3><ul><li>大小5MB左右</li><li>除非手动清除,否则永远存在</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>localStorage和sessionStorage都具有相同的操作方法: setItem、getItem和removeItem</p></div>',61),r=[o];function h(s,c,d,n,u,p){return i(),a("div",null,r)}const P=l(t,[["render",h]]);export{q as __pageData,P as default};
