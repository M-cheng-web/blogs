import{_ as l,c as s,x as e,t as o,a,N as c,o as d}from"./chunks/framework.78c68b71.js";const G=JSON.parse('{"title":"MVVM总结","description":"","frontmatter":{},"headers":[],"relativePath":"web-basics/vue/mvvm.md","lastUpdated":1670155339000}'),r={name:"web-basics/vue/mvvm.md"},n=c('<h1 id="mvvm总结" tabindex="-1">MVVM总结 <a class="header-anchor" href="#mvvm总结" aria-label="Permalink to &quot;MVVM总结&quot;">​</a></h1><p>代码实现地址: <a href="https://github.com/M-cheng-web/vue-sound-mvvm" target="_blank" rel="noreferrer">https://github.com/M-cheng-web/vue-sound-mvvm</a></p><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>这套代码简单实现了 vue框架的双向绑定核心功能<br> 实现功能点:</p>',4),p=e("li",null,"模拟 Vue,通过创建 Vue实例对象的方式完成数据的渲染以及双向绑定的配置",-1),i=e("li",null,"watch监听(可以拿到新值旧值)",-1),h=e("li",null,"data值渲染页面",-1),u=e("li",null,"computed属性渲染到页面",-1),b=e("li",null,"computed属性缓存",-1),_=e("li",null,"computed属性没用到时不会计算",-1),m=e("li",null,"computed属性依赖于多重属性(计算属性A = 计算属性B + dataA, 计算属性B = dataB + dataC)",-1),D=e("li",null,"methods方法",-1),A=e("h2",{id:"项目运行",tabindex:"-1"},[a("项目运行 "),e("a",{class:"header-anchor",href:"#项目运行","aria-label":'Permalink to "项目运行"'},"​")],-1),v=e("ol",null,[e("li",null,[a("vscode内下载"),e("code",null,"Live Server"),a("插件")]),e("li",null,[a("项目拉到本地后点开 www => index.html,右键选择"),e("code",null,"Open With Live Server")])],-1),w=e("h2",{id:"关于模板字符串",tabindex:"-1"},[a("关于模板字符串 "),e("a",{class:"header-anchor",href:"#关于模板字符串","aria-label":'Permalink to "关于模板字符串"'},"​")],-1),y=e("br",null,null,-1),C=e("br",null,null,-1),g=e("br",null,null,-1),F=e("a",{href:"https://github.com/M-cheng-web/vue-sound-mustache",target:"_blank",rel:"noreferrer"},"https://github.com/M-cheng-web/vue-sound-mustache",-1),k=c('<h2 id="什么是计算属性缓存" tabindex="-1">什么是计算属性缓存? <a class="header-anchor" href="#什么是计算属性缓存" aria-label="Permalink to &quot;什么是计算属性缓存?&quot;">​</a></h2><p>例如当A计算属性 = B计算属性 + C计算属性, 而C计算属性 = dataA + dataB<br> 如果C计算属性先于A计算属性执行,那么运算A计算属性的时候并不会再次去运算C计算属性,而是去拿它的缓存(除非在这个过程中dataA或者dataB发生改变)<br> 如果A计算属性先于C计算属性执行,那么运算A计算属性的时候会去运算C计算属性,当其他地方用到C的时候同样也会去拿C的缓存,而不是再次运算(除非dataA或者dataB发生改变)<br></p><h2 id="核心概念了解" tabindex="-1">核心概念了解 <a class="header-anchor" href="#核心概念了解" aria-label="Permalink to &quot;核心概念了解&quot;">​</a></h2><h3 id="object-defineproperty" tabindex="-1">Object.defineProperty <a class="header-anchor" href="#object-defineproperty" aria-label="Permalink to &quot;Object.defineProperty&quot;">​</a></h3><p>这个就是基础原理,了解 <code>api</code> 后我们能知道依赖于这个能让我们知道某个值依赖于某些值,然后才能让我们拿到依赖的值接着再做一些依赖项的绑定</p><p>在实际运用中,我们会给 <code>data</code> 内的所有值以及值内的对象都套上 <code>Object.defineProperty</code> 来截取其 <code>get() set()</code>, <code>computed</code> 也会套上用来截取其 <code>get()</code></p><h3 id="watcher" tabindex="-1">Watcher <a class="header-anchor" href="#watcher" aria-label="Permalink to &quot;Watcher&quot;">​</a></h3><p>双向绑定核心对象<br> 主要完成以下功能:<br></p><ol><li>融合data,computed,watch需要的功能(渲染,更改,获取,缓存)</li><li>生成所有值的实例对象,在某个属性依赖其他属性时会将其属性的watcher实例放入自身,以此来实现查找功能</li></ol><h3 id="dep依赖收集器" tabindex="-1">dep依赖收集器 <a class="header-anchor" href="#dep依赖收集器" aria-label="Permalink to &quot;dep依赖收集器&quot;">​</a></h3><p>我们都知道通过 <code>Object.defineProperty</code> 能让我们知道谁用到了这个值,可具体实现是依赖于 <code>Dep</code> 构造函数的,内部其实很简单, 就只有一个 <code>dep</code> 数组属性,里面会存放依赖于这个值的 <code>watcher</code> 实例,打个比方: <code>a = b + c</code>,那么b的 dep 内会存放着 a 的watcher实例对象</p><p>在实际运用中,我们会给每个 <code>data</code>, <code>computed</code> 属性都创建一个 <code>Dep</code> 实例(如果某个data值内是对象也会给其创建Dep实例,会一直递归到非对象的属性),这样在拦截到某个属性被 <code>get</code> 时,我们就可以利用闭包原理,在其 <code>dep</code> 数组中加入那个调用此属性的 <code>watcher</code> 实例</p><p>以此就完成了依赖收集的作用,然后在当某个属性发生变化时,会触发 <code>Object.defineProperty</code> 的 <code>set</code>,内部会循环 <code>dep</code> 数组用来通知依赖此值的 <code>watcher</code> 实例对象要做出动作</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>为什么用 Set 结构来防止重复?<br> 例如有两个计算属性是依赖于dataA,第一遍计算出那两个计算属性时,dataA的dep是收集了他俩的watcher 但是当其中一个计算属性重新计算时(比如另外一个依赖项改动了会影响此计算属性重新计算),会再次调取dataA 的get拦截,也就是会再次触发 dep.addSub(),如果不加重复过滤这样的场景会一直递增下去,然后当dataA发生 更改时遍历其subs,届时有太多不需要遍历的watcher,很大概率卡死</p></div><h3 id="管理全局唯一的收集栈" tabindex="-1">管理全局唯一的收集栈 <a class="header-anchor" href="#管理全局唯一的收集栈" aria-label="Permalink to &quot;管理全局唯一的收集栈&quot;">​</a></h3><p><code>Dep</code> 构造函数有一个静态属性 <code>target</code></p><ul><li><p>为什么需要这个属性? 在上面我们讲到 <code>Dep</code> 是专门用来收集依赖的,可我们需要一个载体来先存储着那个需要被收集的 <code>watcher</code>, 因为我们并不能做到实时的存储依赖,只能通过第三方来中转一下( 类似于把 A值赋值给B,需要C来中转一下 )</p></li><li><p>为什么是静态属性? 因为保证了全局唯一</p></li><li><p>怎么去管理它? 假设一个场景: <code>计算属性 A = 计算属性 B + 普通属性 C</code> <code>计算属性B = 普通属性 D + 普通属性 E</code></p></li></ul><p>我们在得到A的过程中会将A的 <code>watcher</code> 对象存入 <code>Dep.target</code>,然后刚刚存入的会放到B和C的 <code>dep</code> 数组中(肯定会先计算B,我这边只是先这样概括),目前为止都是没问题的,但是,接着在得到B的过程中, <code>Dep.target</code> 中放的还是 A的 <code>watcher</code> 对象,然后在D和E中的 <code>dep</code> 数组中放入, 预期应该是在D和E中的 <code>dep</code> 数组中放入B的 <code>wathcer</code> 对象</p><p>直接将 <code>Dep.target</code> 替换为B的 <code>watcher</code> 对象也不合理,那么在后续的C的 <code>dep</code> 数组中放入的也会是B的 <code>watcher</code> 对象,预期也应该是放入A的</p><p>结论: 这就要求我们有一个机制可以存储 <code>Dep.target</code>,在我们需要的时候给出目标对象,在不需要的时候就弹出它,那就是栈结构<br> 解决方案: 还是接着上面的例子,在存储 <code>Dep.target</code> 之前,我们可以先判断当前 <code>Dep.target</code> 有没有值,如果有值的话会将此值保存到栈结构后再进行替换,用完了之后再替换回来</p><h3 id="targetstack" tabindex="-1">targetStack <a class="header-anchor" href="#targetstack" aria-label="Permalink to &quot;targetStack&quot;">​</a></h3><p>对Dep.target静态属性操作的封装<br></p><p>应用场景: A计算属性 = B计算属性 + C计算属性, B计算属性 = dataA + dataB, C计算属性 = dataC + dataD<br> 在算A的时候会将A的watcher实例放入Dep.target,然后再执行A的获取值的方法(B计算属性 + C计算属性)<br> 在算B的时候会将当前Dep.target存的值放入B的subs中(也就是存储了A的依赖,在B变化时会能通知到A也更新的操作)<br> 然后将B的watcher实例放入全局的Dep.target,注意,这个时候如果直接替换会把之前存入Dep.target的A的watcher实例给替换掉<br> 在计算(dataA + dataB)的过程中,这俩个值都能正确存储依赖他们的值<br> 最后再算C的时候,也会将当前Dep.target存的值放入C的subs中,但是这个时候Dep.target存的是B的watcher,按道理这个时候Dep.target应该存的是 A的watcher,这样C才能知道当C改变的时候需要通知A<br></p><p>结论: 我们需要一个能自动控制当前Dep.target值的算法,且当前Dep.target有值的时候要存储起来,不能直接替换<br> 解决: targetStack利用栈原理很好的解决了这个问题</p><h2 id="各个模块解析" tabindex="-1">各个模块解析 <a class="header-anchor" href="#各个模块解析" aria-label="Permalink to &quot;各个模块解析&quot;">​</a></h2><h3 id="index-js" tabindex="-1">index.js <a class="header-anchor" href="#index-js" aria-label="Permalink to &quot;index.js&quot;">​</a></h3><p>项目入口<br> MVVM实例对象(下面统称vue实例)的创建,在实例化对象中会初始化data,computed,watch<br> 会将data中的所有属性附加到vue实例上,并与data中所有属性互相绑定(vue实例中这个属性改变也会触发data的这个属性改变)</p><h3 id="observer-js" tabindex="-1">observer.js <a class="header-anchor" href="#observer-js" aria-label="Permalink to &quot;observer.js&quot;">​</a></h3><p>为所有data属性添加响应式<br> 会在 <code>vue实例</code> 以及 <code>vue实例.data</code> 中挂载所有的data值<br> 之所以也要在 <code>vue实例.data</code> 挂载是因为程序内部其他地方都是通过 <code>data[key]</code> 的方式调用 data属性,并不是通过 <code>this[key]</code> 的方式<br> 通过 <code>this[key]</code> 的方式最终都会转移到 <code>this.data[key]</code> 中</p><h3 id="computed-js" tabindex="-1">computed.js <a class="header-anchor" href="#computed-js" aria-label="Permalink to &quot;computed.js&quot;">​</a></h3><p>为所有computed属性添加响应式<br></p><p>特性:</p><ol><li>没有调用的时候不会执行内部方法</li><li>有缓存,重复调用会直接取其缓存值</li><li>计算属性的依赖值发生更改后不会立刻重新运算这个计算属性,而是等需要它的时候才会再次执行(如果是在DOM上的计算属性就会立刻重新运算)</li></ol><p>在为所有computed属性生成watcher实例后,会开启对属性的监听,当这个属性被get的时候会判断这个属性的值是否为最新值<br> 如果是最新值则不需要再进行运算,直接取旧值(注意,取旧值也要将当前Dep.target所存的watcher实例放入这个计算属性的subs中)<br> 如果不是最新值则需要再次运算,先将当前Dep.target存入subs,然后再运算这个计算属性的值,在运算结束后会将这个值标记为最新值,且存储了这个最新值<br> 如果这个标记不变的话,以后会直接用这个存储的最新值(只有当这个值所依赖的值发生改变才会改变这个值的标记)</p><h3 id="watcher-js" tabindex="-1">watcher.js <a class="header-anchor" href="#watcher-js" aria-label="Permalink to &quot;watcher.js&quot;">​</a></h3><p>为需要的属性创建watcher实例<br> 充当着观察者的身份,给 <code>computed</code>, <code>watch</code> 还有渲染函数使用的,在创建时就会给每个属性或者watch绑定一个watcher实例,里面记录了一些关于属性的信息以及必要的方法,然后会把这个实例放入其依赖的属性的 dep数组中,在被依赖属性发生改变时就会通知到这个watcher实例</p><blockquote><p>其实在我看来就是一个统一管理的地方,当属性创建的时候要绑定此实例,在更改时也通知此实例,整个双向绑定就是围绕着这个关键的watcher</p></blockquote><p>它的原型链上有四个方法,分别为: <code>update</code> <code>get</code> <code>watchGet</code> <code>depend</code>,详细代码在文件中</p><ul><li>update: 在依赖的属性发生变化时会通知到这个方法,通过此方法来执行相对应操作</li><li>get: 获取值,并处理 <code>Dep.target</code> 的出栈入栈,从而达到绑定依赖项</li><li>watchGet: 给监听使用,在watch初始化时会调用目标属性然后让其收集此监听的 <code>watcher</code>,以达到在值发生改变通知到监听</li><li>depend: 给计算属性添加 dep的</li></ul><h3 id="watch-js" tabindex="-1">watch.js <a class="header-anchor" href="#watch-js" aria-label="Permalink to &quot;watch.js&quot;">​</a></h3><p>实现监听<br> 遍历所有watch,将被watch的属性改变后需要触发的函数放入watcher的callback回调中<br> 在第一次加载的时候就会调用一次被监听的属性,以达到被这个属性存放在其subs中,当这个属性变化时自然能通知到watch</p><blockquote><p>watch 监听一个 computed 属性,如果这个属性一开始并不会执行,那么也应该在被监听的时候也不要执行,但是我写的这一块还是会执行的,后续康康把...</p></blockquote><h3 id="compile-js" tabindex="-1">compile.js <a class="header-anchor" href="#compile-js" aria-label="Permalink to &quot;compile.js&quot;">​</a></h3>',43),f=e("br",null,null,-1),q=e("code",null,"v-model",-1),j=e("code",null,"v-on:click",-1),P=e("code",null,"v-on:click",-1),B=e("br",null,null,-1),x=e("code",null,"v-model",-1),T=e("code",null,"watcher",-1),S=e("code",null,"watcher",-1),V=e("br",null,null,-1),M=c(`<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">updateText</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">textContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">undefined</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">},</span></span>
<span class="line"></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>渲染这一块我也是看网上的例子拿到的,真实渲染并不是这样,但这是最快的方式,所以仅供参考,最主要的是双向绑定那一块逻辑</p></div>`,2);function O(t,E,I,N,$,R){return d(),s("div",null,[n,e("ul",null,[p,i,h,u,b,_,m,D,e("li",null,"v-model "+o(t.data)+" v-on 功能的简单完成",1)]),A,v,w,e("p",null,[a("内部的 v-model,事件以及模板字符串的实现可以先不用在意(这里只是简单应用,并不是vue实际实现方式)"),y,a(" 建议直接看 compole.js中compileText() 以及 compileModel()方法"),C,a(" 这俩个方法是将 v-model='title' 以及 "+o(t.title)+" 中的title转化为实际值并且渲染页面的关键方法",1),g,a(" 如果对模板字符串感兴趣的话可以参考我关于这一块的源码实现 "),F]),k,e("p",null,[a("html页面的功能实现,主要实现了v-model,v-on,"+o(t.title)+"模板字符串功能",1),f,a(" 对页面DOM做了处理,使其可以支持类似于vue的 "),q,a(),j,a(",同样也对这些方法进行了事件绑定 比如使用了 "),P,a("会监听那个元素的点击事件,触发后会执行目标方法"),B,a(" 比如使用了 "),x,a("会为其创建一个 "),T,a(" 实例并标明此是渲染函数,然后会执行内部的 update方法使依赖属性的dep中存放此 "),S,V]),e("p",null,[a("同理一般的计算属性或者data值放在页面中通过 "),e("code",null,o(t.name),1),a(" 的方式也会被检测到此DOM元素需要将name转化为真实值,在转化的过程中会得到真实name 的值,同时也会将下面的更改DOM元素textContent方法暴露出去,以便在值发生变化后能执行此方法来改变页面的值")]),M])}const L=l(r,[["render",O]]);export{G as __pageData,L as default};
