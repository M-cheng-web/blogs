# JS 基础

![JS基础简图](https://gitee.com/M-cheng-web/map-storage/raw/master/vue-img/71e30bdc18b44272b5fa0e16b9c3f2e8_tplv-k3u1fbpfcp-watermark.webp)

## 执行上下文/作用域/闭包
### JS执行上下文
有三种执行上下文类型
1. 全局执行上下文 - 基础的上下文,任何不在函数内部的代码都在全局上下文中 会执行两件事: 创建一个全局的 window 对象(浏览器情况下),并且设置this 的值等于这个全局对象,一个程序中只会有一个全局执行上下文
2. 函数执行上下文 - 每当一个函数被调用时,都会生成一个函数执行上下文,然后这个函数执行上下文会执行这个函数
3. Eval函数执行上下文 - 执行Eval函数时也会生成属于它的执行上下文

### JS执行栈
是一种后进先出的数据结构,被用来存储执行上下文

当程序开始运行时,会将全局执行上下文压入栈底,随后在代码运行中发现新的需要执行的函数,就会生成这个函数的上下文并放入执行栈中并执行这个函数,如果这个函数内也有需要执行的函数,会继续生成并放入

当没有可以继续生成的函数上下文时或者是函数已经执行完毕,会将这个函数 从执行栈中弹出

> 比如说 A函数调用 B函数,B函数调用 C函数这样的执行就是依照着后进先出的模式

### JS作用域/作用域链
作用域规定了如何查找变量,也就是确定当前执行代码对变量的访问权限,JS采用词法作用域,也就是静态作用域

静态作用域与动态作用域
+ 静态作用域中的函数作用域在函数定义的时候就决定了
+ 动态作用域中的函数作用域在函数调用的时候才决定
``` js
var value = 1;
// 执行 foo 函数, 先从 foo 函数内部查找是否有局部变量 value
// 如果没有就根据书写的位置,查找上面一层的代码,也就是 value 等于 1,所以结果会打印 1
function foo() {
  console.log(value);
}
function bar() {
  var value = 2;
  foo();
}
bar(); // 1
```

**为什么函数作用域在函数定义的时候就决定了?**

这是因为函数有一个内部属性 [[scope]],当函数创建的时候,就会保存所有父变量对象到其中,
可以理解 [[scope]] 就是所有父变量对象的层级链
``` js
function foo() {
  function bar() {
    ...
  }
}
// 函数创建时,各自的[[scope]]为:
foo.[[scope]] = [
  globalContext.VO
];
bar.[[scope]] = [
  fooContext.AO,
  globalContext.VO
];
```

**作用域链**

当查找变量的时候,会先从当前上下文的变量对象中查找,如果没有找到,就会从父级(词法层面上的父级)执行上下文的变量对象中查找,
一直找到全局上下文的变量对象,也就是全局对象,
这样由多个执行上下文的变量对象构成的链表就叫做作用域链

### JS闭包
闭包是一个可以访问外部作用域中变量的内部函数,这些被引用的变量直到闭包被销毁时才会被销毁

应用场景: 私有变量,工程函数,vue中watch监听,promise等等


## this/call/apply/bind
### JS里的this
this为当前的执行环境,根据this可以拿到属性和函数,分为全局this和函数中的this
+ 全局的this指向它本身
+ 函数的this的指向,是在函数被调用的时候确定的( 也就是执行上下文被创建时确定的 )

在一个函数上下文中,this由调用者提供,由调用函数的方式来决定
+ 被调用的函数属于一个对象,那么该函数在调用时,内部的this指向该对象
+ 函数独立调用,那么该函数内部的this,则指向undefined( 但是在非严格模式中,当this指向undefined时,它会被自动指向全局对象 )

### 改变this指向
call,apply,bind,以及箭头函数
+ call和apply功能一样,只是传参的方式不一样,一个接收多个字符串,一个接收数组,bind会返回函数并不是运行
+ 箭头函数是在函数创建时就会绑定确定函数内容中的this指向,而不是在运行时确定

## 原型/继承
参考 [对象](./object.md)

## 深浅拷贝
参考 [ 手写深浅拷贝 ](../writingcode/copy.md)

## 事件机制/Event Loop
### 如何实现一个事件的发布订阅

### 事件循环
JS是单线程的并且JS单线程执行方式是基于事件循环的,因为它在执行任务的时候会产生一个任务队列

这个任务队列是先进先出的,分为宏任务和微任务,在遇到异步事件时会将事件先存入这个任务队列,在同步事件

都完成后才会开始执行任务队列,当这个任务队列里还存在异步事件还会接着存入任务队列,这个过程就是事件循环

### 宏任务和微任务有什么区别
+ 宏任务与微任务都是异步队列,区别在于微任务比宏任务的优先级高,如果是在同一层级的话微任务是会在任务队列的最前面
+ 宏任务会在最后面,比如setTimeOut,setInterVal, 微任务比如Promise

## 函数式编程
这里只是打个样,网上有很多方式
### 函数柯里化
``` js
var person = [{name: 'kevin'}, {name: 'daisy'}]
curry = function(fn) {
  return function(key) {
    return (item) => item[key];
  }
}
var prop = curry(function (key, obj) {
  return obj[key]
});
var name = person.map(prop('name'))
console.log('name', name); // kevin,daisy
```
